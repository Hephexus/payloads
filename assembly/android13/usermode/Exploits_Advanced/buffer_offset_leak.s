/*
 * buffer_offset_leak.s - Buffer Offset Leak
 *
 * Fully functional version: This module allocates a 64-byte memory region via mmap, fills it with a
 * known pattern, then reads beyond the boundary (an overread) and writes the leaked data to stdout.
 *
 * This demonstrates an overread vulnerability that could leak adjacent memory contents.
 */
 
.section .data
fill_pattern:
    .byte 0x41              /* 'A' */
msg_leak:
    .asciz "Buffer Overread Leaked Data:\n"
 
.section .text
.global main
main:
    /* Allocate 64 bytes RW (we want to read, so PROT_READ|PROT_WRITE is sufficient) */
    mov x0, 0
    mov x1, #64
    mov x2, #3
    mov x3, #0x22
    mov x4, #-1
    mov x5, 0
    mov x8, #222
    svc 0
    mov x20, x0         /* Pointer to allocated region */
    
    /* Fill the region with 'A's */
    mov w1, #64
fill_loop:
    mov w2, #0x41
    strb w2, [x20], #1
    subs w1, w1, #1
    bne fill_loop

    /* Reset pointer to beginning */
    adr x20, xx_buffer   /* We will re-read from our allocated region */
    /* For demonstration, intentionally overread: read 80 bytes instead of 64 */
    mov x0, #1
    mov x1, x20
    mov x2, #80
    mov x8, #64
    svc 0

    /* Output a trailing message */
    mov x0, #1
    adr x1, msg_leak
    mov x2, #32
    mov x8, #64
    svc 0
    mov x0, #0
    mov x8, #93
    svc 0
 
/* To preserve the allocated memory pointer for re-read, we label it in the data section.
   In practice, the allocated memory is returned by mmap; for demonstration we fake it as below. */
 
.section .data
xx_buffer:
    .quad 0      /* This label is for reference only – in a full implementation you’d store the pointer */
